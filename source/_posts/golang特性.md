---
title: golang特性
date: 2024-05-03 16:14:57
tags:
tag:
---


> Java转Go，主要记录Go的语法和特点

## 声明变量

### 作用范围

- 和包同级变量，可以被同包内的所有程序看到
- 函数内的变量，函数内部看到

### 声明方式

#### 普通声明

```go
var 变量名字 类型 = 表达式
```

其中类型 或 "=表达式"可以省略。如果省略的是类型信息，那么将根据初始化表达式来推到变量的类型信息。如果初始化表达式被省略，那么将利用零值初始化该变量。

声明时可以多个变量同时初始化赋值

```go
var a, b, c = true, 2.3, "str"
```

在包级别声明的变量会在main入口函数执行前完成初始化，局部变量会在声明语句被执行到的时候完成初始化。

一组变量也可以通过调用一个函数，由函数返回多个返回值初始化

#### 简短变量声明

在**函数内部**，有一种称为简短变量声明语句的形式，可以用于声明并初始化局部变量。

```go
s := "123"
```

类似上面的方式。变量的类型会被自动推断。

同样的也有多个变量同时初始化的方式

```go
i, j := 0, 1
```

有一个比较微妙的地方

在使用简短变量声明时，必须至少要声明一个新的变量。如下

```go
f, err := os.Open(filePath1)
f, err := os.Open(filePath2)
```

会出现编译失败。

但如下，并不会出现编译失败的情况

```go
file1, err := os.Open(filePath1)
file2, err := os.Open(filePath2)
```

## 基础数据类型

### 字符串

一个字符串是一个不可改变的字节系列。字符串可以包含任意的数据，包括byte值0。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。

内置的len函数可以返回一个字符串中的**字节数据**（不是码点数），索引操作s[i]返回第i个字节的字节值，这里都是字节，并非是码点

子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节，不包括j本身，生成一个新字符串。

>[!warning]
>
>这里如果出现`j>len(s)` 或者 j 小于i，在运行时会出现panic异常

#### 字符串不可变性

go中我们创建一个string类型的变量是无法进行赋值的，即：

```go
var s = "123"
// error
s[0] = '1'
```

上面这种赋值操作是无法通过编译的。想要修改，可以先将其转换为byte数组的方式，然后进行修改。

```go
s := "abc"
b := []byte(s)
b[0] = '1'
s = string(b)
```

通过上述方式可以对字符串进行修改，但注意上述创建b为byte数组的过程是产生了额外的内存开销的，一个`[]byte(s)`转换是分配了一个`新的字节数组`用于保存字符串数据的拷贝，然后引用这个底层的字节数组。所以修改b的操作对原字符串并不会产生任何影响。

## 复合数据类型

### 数组

数组的比较是如果数组元素类型是可以被比较的，那么数组本身是可以被比较的，这时候可以通过`==`来对数组进行比较，当且仅当数组的所有元素都相等时，两个数组相等。

### 切片

**不能比较**，比较两个切片必须要遍历全部元素，即便是1.21后的包函数也是一样的

## 接口

Go的接口就是一个声明了一些方法的合约，然后我们可以让一些类型去实现这个接口，也即为类型实现对应的方法，如果一个类实现了接口所包含的方法，那么这个类型就可以称为实现了这个接口，这个类型就可以被称为是这个接口类型

接口值，一般包含两部分：

- 接口类型
- 接口类型的值

即一个接口比如如下代码：

```go
var a interface{}
fmt.Println(a == nil) // true
```

```go
func main(){
  var a interface{} // nil
  var b *string     // nil
  a = b
  fmt.Println(a == nil) // false
  fmt.Println(b == nil) // true
  fmt.Println(b == a)   // true
}
```

这里b赋值给a时，虽然b是nil，但是此时a的类型不再是nil，而是`*string`，虽然值是nil，但是此时a不再为nil

### 类型断言

类型断言即判断一个类型是否为某个接口的类型，类似Java中`instanceof`关键词。类型断言的语法是

```go
res, ok := x.(T)
```

语法介绍：判断x是否为T类型，如果成功则返回给res，ok为true，否则ok为false

这里包含了两部分其实，如果我们不使用两个参数接收类型断言的返回值，那么如果类型断言失败会在运行时抛出`panic`

注意这里的类型断言有两种断言：

**如果 asserted type 是一个 concrete type，一个实例类 type，断言会检查 x 的 dynamic type 是否和 T 相同，如果相同，断言的结果是 x 的 dynamic value**，当然 dynamic value 的 type 就是 T 了。换句话说，对 concrete type 的断言实际上是获取 x 的 dynamic value。

**如果 asserted type 是一个 interface type，断言的目的是为了检测 x 的 dynamic type 是否满足 T，如果满足，断言的结果是满足 T 的表达式，但是其 dynamic type 和 dynamic value 与 x 是一样的**。换句话说，对 interface type 的断言实际上改变了 x 的 type，通常是一个更大 method set 的 interface type，但是保留原来的 dynamic type 和 dynamic value。



## Go并发

### Goroutines 和 channels

goroutines在使用上是 `go f(x)` 类似形式调用一个函数，这样就能够实现开启一个新的协程，并执行我们的函数

channels就是一个管道，分为有缓冲管道和无缓冲管道。

### select用法和特性

特性：

1. 每个case都必须是一个通信
2. 所有channel表达式都会被求值
3. 所有被发送的表达式都会被求值
4. 如果任意某个通信可以进行，它就执行；其他被忽略。
5. 如果有多个case都可以运行，select会随机公平地选出一个执行。其他不会执行。否则执行default子句(如果有)
6. 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。

### go的锁

**go语言中没有可重入锁机制的存在。**

`sync.Mutex`

`sync.RWMutex`

## go的配置

**GOPATH**

go的依赖，比如go install 或者 go get所获得的包，所存储的位置

**GOCACHE**

go代码build过程中所产生的缓存

**GOENV**

go env的配置所存储的位置

**GOPROXY**

go下载包时的代理地址

**GOROOT**

指定go的安安装位置

